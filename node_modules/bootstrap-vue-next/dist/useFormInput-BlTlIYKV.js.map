{"version":3,"file":"useFormInput-BlTlIYKV.js","sources":["../src/utils/normalizeInput.ts","../src/composables/useFormInput.ts"],"sourcesContent":["import type {Numberish} from '../types/CommonTypes'\n\nexport const normalizeInput = (\n  v: Numberish | null,\n  modelModifiers: Record<'number' | 'lazy' | 'trim', true | undefined>\n) => {\n  if (v === null) return\n  let update = v\n  if (modelModifiers.number && typeof update === 'string' && update !== '') {\n    const parsed = Number.parseFloat(update)\n    update = Number.isNaN(parsed) ? update : parsed\n  }\n  return update\n}\n","import type {Numberish} from '../types/CommonTypes'\nimport {\n  computed,\n  inject,\n  nextTick,\n  onActivated,\n  onMounted,\n  ref,\n  type Ref,\n  type ShallowRef,\n} from 'vue'\nimport {useAriaInvalid} from './useAriaInvalid'\nimport {useId} from './useId'\nimport {useFocus, useToNumber} from '@vueuse/core'\nimport type {CommonInputProps} from '../types/FormCommonInputProps'\nimport {formGroupKey} from '../utils/keys'\nimport {useDebounceFn} from '../utils/debounce'\nimport {useStateClass} from './useStateClass'\n\nexport const useFormInput = (\n  props: Readonly<CommonInputProps>,\n  input:\n    | Readonly<ShallowRef<HTMLInputElement | null>>\n    | Readonly<ShallowRef<HTMLTextAreaElement | null>>,\n  modelValue: Ref<Numberish | null>,\n  modelModifiers: Record<'number' | 'lazy' | 'trim', true | undefined>\n) => {\n  const forceUpdateKey = ref(0)\n\n  const computedId = useId(() => props.id, 'input')\n  const debounceNumber = useToNumber(() => props.debounce ?? 0, {nanToZero: true})\n  const debounceMaxWaitNumber = useToNumber(() => props.debounceMaxWait ?? Number.NaN)\n\n  // This automatically adds the appropriate \"for\" attribute to a BFormGroup label\n  const formGroupData = inject(formGroupKey, null)?.(computedId)\n  const computedState = computed(() =>\n    props.state !== undefined ? props.state : (formGroupData?.state.value ?? null)\n  )\n  const computedAriaInvalid = useAriaInvalid(() => props.ariaInvalid, computedState)\n  const stateClass = useStateClass(computedState)\n\n  const internalUpdateModelValue = useDebounceFn(\n    (value: Numberish) => {\n      modelValue.value = value\n    },\n    () => (modelModifiers.lazy === true ? 0 : debounceNumber.value),\n    {maxWait: () => (modelModifiers.lazy === true ? Number.NaN : debounceMaxWaitNumber.value)}\n  )\n\n  const updateModelValue = (value: Numberish, force = false, immediate = false) => {\n    if (modelModifiers.lazy === true && force === false) return\n    if (immediate) {\n      modelValue.value = value\n    } else {\n      internalUpdateModelValue(value)\n    }\n  }\n\n  const {focused} = useFocus(input, {\n    initialValue: props.autofocus,\n  })\n\n  const _formatValue = (value: string, evt: Readonly<Event>, force = false) => {\n    if (props.formatter !== undefined && (!props.lazyFormatter || force)) {\n      return props.formatter(value, evt)\n    }\n    return value\n  }\n  onMounted(() => {\n    if (input.value) {\n      input.value.value = modelValue.value?.toString() ?? ''\n    }\n  })\n\n  onActivated(() => {\n    nextTick(() => {\n      if (props.autofocus) {\n        focused.value = true\n      }\n    })\n  })\n\n  const onInput = (evt: Readonly<Event>) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = formattedValue\n\n    updateModelValue(nextModel)\n  }\n\n  const onChange = (evt: Readonly<Event>) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = formattedValue\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true)\n    }\n  }\n\n  const onBlur = (evt: Readonly<FocusEvent>) => {\n    if (\n      !modelModifiers.lazy &&\n      !props.lazyFormatter &&\n      !modelModifiers.trim &&\n      debounceNumber.value <= 0\n    )\n      return\n\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt, true)\n\n    const nextModel = modelModifiers.trim ? formattedValue.trim() : formattedValue\n    const needsForceUpdate = nextModel.length !== formattedValue.length\n    // Cancel before modelValue.value comparison and update\n    internalUpdateModelValue.cancel()\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true, true)\n    }\n    if (modelModifiers.trim && needsForceUpdate) {\n      // The value is trimmed but there would still exist some white space\n      // So, force update the value. You need to bind this to :key on the input element\n      forceUpdateKey.value = forceUpdateKey.value + 1\n    }\n  }\n\n  const focus = () => {\n    if (!props.disabled) {\n      focused.value = true\n    }\n  }\n\n  const blur = () => {\n    if (!props.disabled) {\n      focused.value = false\n    }\n  }\n\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n    forceUpdateKey,\n    stateClass,\n  }\n}\n"],"names":["v","modelModifiers","update","number","parsed","Number","parseFloat","isNaN","props","input","modelValue","forceUpdateKey","ref","computedId","useId","id","debounceNumber","useToNumber","debounce","nanToZero","debounceMaxWaitNumber","debounceMaxWait","NaN","formGroupData","inject","formGroupKey","computedState","computed","state","value","computedAriaInvalid","useAriaInvalid","ariaInvalid","stateClass","useStateClass","internalUpdateModelValue","useDebounceFn","lazy","maxWait","updateModelValue","force","immediate","focused","useFocus","initialValue","autofocus","_formatValue","evt","formatter","lazyFormatter","onMounted","toString","onActivated","nextTick","onInput","target","formattedValue","defaultPrevented","preventDefault","onChange","nextModel","onBlur","trim","needsForceUpdate","length","cancel","focus","disabled","blur"],"mappings":"qTAE8B,CAC5BA,EACAC,KAEA,GAAU,OAAND,EAAY,OAChB,IAAIE,EAASF,EACb,GAAIC,EAAeE,QAA4B,iBAAXD,GAAkC,KAAXA,EAAe,CACxE,MAAME,EAASC,OAAOC,WAAWJ,GACjCA,EAASG,OAAOE,MAAMH,GAAUF,EAASE,CAC3C,CACA,OAAOF,wBCOmB,CAC1BM,EACAC,EAGAC,EACAT,KAEA,MAAMU,EAAiBC,EAAAA,IAAI,GAErBC,EAAaC,EAAAA,MAAM,IAAMN,EAAMO,GAAI,SACnCC,EAAiBC,EAAAA,YAAY,IAAMT,EAAMU,UAAY,EAAG,CAACC,WAAW,IACpEC,EAAwBH,EAAAA,YAAY,IAAMT,EAAMa,iBAAmBhB,OAAOiB,KAG1EC,EAAgBC,EAAAA,OAAOC,EAAAA,aAAc,KAArBD,GAA6BX,GAC7Ca,EAAgBC,EAAAA,SAAS,SACb,IAAhBnB,EAAMoB,MAAsBpB,EAAMoB,MAASL,GAAeK,MAAMC,OAAS,MAErEC,EAAsBC,EAAAA,eAAe,IAAMvB,EAAMwB,YAAaN,GAC9DO,EAAaC,EAAAA,cAAcR,GAE3BS,EAA2BC,EAAAA,cAC9BP,IACCnB,EAAWmB,MAAQA,GAErB,KAA+B,IAAxB5B,EAAeoC,KAAgB,EAAIrB,EAAea,MACzD,CAACS,QAAS,KAA+B,IAAxBrC,EAAeoC,KAAgBhC,OAAOiB,IAAMF,EAAsBS,QAG/EU,EAAmB,CAACV,EAAkBW,GAAQ,EAAOC,GAAY,MACzC,IAAxBxC,EAAeoC,OAA2B,IAAVG,IAChCC,EACF/B,EAAWmB,MAAQA,EAEnBM,EAAyBN,MAIvBa,QAACA,GAAWC,EAAAA,SAASlC,EAAO,CAChCmC,aAAcpC,EAAMqC,YAGhBC,EAAe,CAACjB,EAAekB,EAAsBP,GAAQ,SACzC,IAApBhC,EAAMwC,WAA6BxC,EAAMyC,gBAAiBT,EAGvDX,EAFErB,EAAMwC,UAAUnB,EAAOkB,GAIlCG,EAAAA,UAAU,KACJzC,EAAMoB,QACRpB,EAAMoB,MAAMA,MAAQnB,EAAWmB,OAAOsB,YAAc,MAIxDC,EAAAA,YAAY,KACVC,EAAAA,SAAS,KACH7C,EAAMqC,YACRH,EAAQb,OAAQ,OAsEtB,MAAO,CACLpB,QACAI,aACAiB,sBACAwB,QArEeP,IACf,MAAMlB,MAACA,GAASkB,EAAIQ,OACdC,EAAiBV,EAAajB,EAAOkB,GAC3C,GAAIA,EAAIU,iBAEN,YADAV,EAAIW,iBAMNnB,EAFkBiB,IA8DlBG,SAzDgBZ,IAChB,MAAMlB,MAACA,GAASkB,EAAIQ,OACdC,EAAiBV,EAAajB,EAAOkB,GAC3C,GAAIA,EAAIU,iBAEN,YADAV,EAAIW,iBAIN,MAAME,EAAYJ,EACd9C,EAAWmB,QAAU+B,GACvBrB,EAAiBiB,GAAgB,IAgDnCK,OA5Ccd,IACd,IACG9C,EAAeoC,OACf7B,EAAMyC,gBACNhD,EAAe6D,MAChB9C,EAAea,OAAS,EAExB,OAEF,MAAMA,MAACA,GAASkB,EAAIQ,OACdC,EAAiBV,EAAajB,EAAOkB,GAAK,GAE1Ca,EAAY3D,EAAe6D,KAAON,EAAeM,OAASN,EAC1DO,EAAmBH,EAAUI,SAAWR,EAAeQ,OAE7D7B,EAAyB8B,SACrBvD,EAAWmB,QAAU+B,GACvBrB,EAAiBiB,GAAgB,GAAM,GAErCvD,EAAe6D,MAAQC,IAGzBpD,EAAekB,MAAQlB,EAAekB,MAAQ,IAuBhDqC,MAnBY,KACP1D,EAAM2D,WACTzB,EAAQb,OAAQ,IAkBlBuC,KAdW,KACN5D,EAAM2D,WACTzB,EAAQb,OAAQ,IAalBlB,iBACAsB"}