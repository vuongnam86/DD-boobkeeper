{"version":3,"file":"utils-DbHbxN8-.js","sources":["../src/directives/utils.ts"],"sourcesContent":["import type {ComponentInternalInstance, Directive, DirectiveBinding, Ref, VNode} from 'vue'\nimport type {BPopoverProps} from '../types/ComponentProps'\nimport {\n  bind,\n  type ElementWithPopper,\n  resolveActiveStatus,\n  resolveContent,\n  resolveDirectiveProps,\n  unbind,\n} from '../utils/floatingUi'\nimport {defaultsKey} from '../utils/keys'\n\ninterface _ComponentInternalInstance extends ComponentInternalInstance {\n  provides?: Record<string, unknown>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  setupState?: any\n}\n\ninterface _VNode extends VNode {\n  ctx?: _ComponentInternalInstance | null\n  ssContent?: VNode | null\n}\n\n/**\n * Represents per-instance state for directives using UID namespacing\n */\nexport interface DirectiveInstanceState {\n  binding: string // JSON.stringify cache for change detection\n  destroying: boolean // Flag to prevent race conditions during cleanup\n}\n\n/**\n * Gets the component instance UID from a directive binding\n * @throws Error if binding.instance is not available\n */\nexport function getDirectiveUid(binding: DirectiveBinding): number {\n  if (!binding.instance) {\n    throw new Error('[Bootstrap-Vue-Next] Directive binding.instance is not available')\n  }\n  return binding.instance.$.uid\n}\n\n/**\n * Initializes UID-namespaced storage on an element for a directive\n * @param el - The HTML element\n * @param propertyName - The property name (e.g., '$__tooltip', '$__popover')\n * @param uid - The component instance UID\n * @param binding - The directive binding value to cache\n * @returns The initialized instance state\n */\nexport function initDirectiveInstance(\n  el: HTMLElement & Record<string, unknown>,\n  propertyName: string,\n  uid: number,\n  binding: DirectiveBinding\n): DirectiveInstanceState {\n  // Initialize UID namespace for this directive\n  const elWithProps = el as Record<string, unknown>\n  elWithProps[propertyName] = elWithProps[propertyName] ?? Object.create(null)\n\n  // Store per-instance state with JSON cache for change detection\n  const state: DirectiveInstanceState = {\n    binding: JSON.stringify([binding.modifiers, binding.value]),\n    destroying: false,\n  }\n\n  ;(elWithProps[propertyName] as Record<string, unknown>)[uid] = state\n  return state\n}\n\n/**\n * Gets the instance state for a directive, if it exists\n * @param el - The HTML element\n * @param propertyName - The property name (e.g., '$__tooltip', '$__popover')\n * @param uid - The component instance UID\n * @returns The instance state or undefined if not found\n */\nexport function getDirectiveInstance(\n  el: HTMLElement & Record<string, unknown>,\n  propertyName: string,\n  uid: number\n): DirectiveInstanceState | undefined {\n  const elWithProps = el as Record<string, unknown>\n  return (elWithProps[propertyName] as Record<string, unknown> | undefined)?.[uid] as\n    | DirectiveInstanceState\n    | undefined\n}\n\n/**\n * Checks if the directive binding has changed for this instance\n * @param instance - The directive instance state\n * @param binding - The current directive binding\n * @returns true if the binding has changed, false otherwise\n */\nexport function hasBindingChanged(\n  instance: DirectiveInstanceState,\n  binding: DirectiveBinding\n): boolean {\n  const newBinding = JSON.stringify([binding.modifiers, binding.value])\n  return instance.binding !== newBinding\n}\n\n/**\n * Updates the cached binding value for a directive instance\n * @param instance - The directive instance state\n * @param binding - The new directive binding\n */\nexport function updateBindingCache(\n  instance: DirectiveInstanceState,\n  binding: DirectiveBinding\n): void {\n  instance.binding = JSON.stringify([binding.modifiers, binding.value])\n}\n\n/**\n * Cleans up a directive instance\n * @param el - The HTML element\n * @param propertyName - The property name (e.g., '$__tooltip', '$__popover')\n * @param uid - The component instance UID\n */\nexport function cleanupDirectiveInstance(\n  el: HTMLElement & Record<string, unknown>,\n  propertyName: string,\n  uid: number\n): void {\n  const elWithProps = el as Record<string, unknown>\n  const instance = (elWithProps[propertyName] as Record<string, unknown> | undefined)?.[uid] as\n    | DirectiveInstanceState\n    | undefined\n  if (instance) {\n    instance.destroying = true\n    delete (elWithProps[propertyName] as Record<string, unknown>)[uid]\n  }\n}\n\n// taken from vuetify https://github.com/vuetifyjs/vuetify/blob/master/packages/vuetify/src/composables/directiveComponent.ts\n\nexport function findProvides(binding: DirectiveBinding, vnode: _VNode): Record<string, unknown> {\n  const provides =\n    (vnode.ctx === binding.instance!.$\n      ? findComponentParent(vnode, binding.instance!.$)?.provides\n      : vnode.ctx?.provides) ?? binding.instance!.$.provides\n\n  return provides\n}\n\nexport function findComponentParent(\n  vnode: VNode,\n  root: ComponentInternalInstance\n): _ComponentInternalInstance | null {\n  // Walk the tree from root until we find the child vnode\n  const stack = new Set<VNode>()\n  const walk = (children: _VNode[]): boolean => {\n    for (const child of children) {\n      if (!child) continue\n\n      if (child === vnode || (child.el && vnode.el && child.el === vnode.el)) {\n        return true\n      }\n\n      stack.add(child)\n      let result\n      if (child.suspense) {\n        result = walk([child.ssContent!])\n      } else if (Array.isArray(child.children)) {\n        result = walk(child.children as VNode[])\n      } else if (child.component?.vnode) {\n        result = walk([child.component?.subTree])\n      }\n      if (result) {\n        return result\n      }\n      stack.delete(child)\n    }\n\n    return false\n  }\n  if (!walk([root.subTree])) {\n    // eslint-disable-next-line no-console\n    console.error('Could not find original vnode,  will not inherit provides')\n    return root\n  }\n\n  // Return the first component parent\n  const result = Array.from(stack).reverse()\n  for (const child of result) {\n    if (child.component) {\n      return child.component\n    }\n  }\n  return root\n}\n\n/**\n * Creates a floating UI directive (tooltip or popover) with UID-namespaced state management\n * @param propertyName - The property name for storing state (e.g., '$__tooltip', '$__popover')\n * @param componentDefaultsKey - The key for accessing component defaults (e.g., 'BTooltip', 'BPopover')\n * @param buildProps - Optional function to customize the props passed to bind()\n * @returns A Vue directive object\n */\nexport function createFloatingDirective(\n  propertyName: string,\n  componentDefaultsKey: string,\n  buildProps?: (\n    text: {title?: string; body?: string},\n    defaults: unknown,\n    binding: Readonly<DirectiveBinding>,\n    el: Readonly<HTMLElement>\n  ) => BPopoverProps\n): Directive<ElementWithPopper> {\n  return {\n    mounted(el, binding, vnode) {\n      const uid = getDirectiveUid(binding)\n      const defaultsMap = (findProvides(binding, vnode) as Record<symbol, Ref>)[defaultsKey]\n        ?.value as Record<string, unknown> | undefined\n      const isActive = resolveActiveStatus(binding.value)\n      if (!isActive) return\n\n      const text = resolveContent(binding.value, el)\n\n      if (!text.body && !text.title) return\n\n      // Initialize per-instance state with UID namespacing\n      initDirectiveInstance(el, propertyName, uid, binding)\n\n      const props = buildProps\n        ? buildProps(text, defaultsMap?.[componentDefaultsKey], binding, el)\n        : {\n            ...(defaultsMap?.[componentDefaultsKey] || undefined),\n            ...resolveDirectiveProps(binding, el),\n            ...text,\n          }\n\n      bind(el, binding, props)\n    },\n\n    updated(el, binding, vnode) {\n      const uid = getDirectiveUid(binding)\n      let instance = getDirectiveInstance(el, propertyName, uid)\n\n      const defaultsMap = (findProvides(binding, vnode) as Record<symbol, Ref>)[defaultsKey]\n        ?.value as Record<string, unknown> | undefined\n\n      const isActive = resolveActiveStatus(binding.value)\n\n      // If inactive, clean up existing instance if present\n      if (!isActive) {\n        if (instance && el.$__element) {\n          unbind(el)\n          cleanupDirectiveInstance(el, propertyName, uid)\n        }\n        return\n      }\n\n      const text = resolveContent(binding.value, el)\n\n      if (!text.body && !text.title) {\n        // Clean up if no content\n        if (instance && el.$__element) {\n          unbind(el)\n          cleanupDirectiveInstance(el, propertyName, uid)\n        }\n        return\n      }\n\n      // If instance doesn't exist, this is a transition from inactive/no-content to active\n      // Initialize the instance now (similar to mounted)\n      if (!instance) {\n        instance = initDirectiveInstance(el, propertyName, uid, binding)\n\n        const props = buildProps\n          ? buildProps(text, defaultsMap?.[componentDefaultsKey], binding, el)\n          : {\n              ...(defaultsMap?.[componentDefaultsKey] || undefined),\n              ...resolveDirectiveProps(binding, el),\n              ...text,\n            }\n\n        bind(el, binding, props)\n        return\n      }\n\n      // Check if binding changed for THIS instance\n      if (!hasBindingChanged(instance, binding)) return\n\n      // Prevent race conditions during update\n      if (instance.destroying) return\n\n      unbind(el)\n\n      const props = buildProps\n        ? buildProps(text, defaultsMap?.[componentDefaultsKey], binding, el)\n        : {\n            ...(defaultsMap?.[componentDefaultsKey] || undefined),\n            ...resolveDirectiveProps(binding, el),\n            ...text,\n          }\n\n      bind(el, binding, props)\n\n      // Update THIS instance's cache\n      updateBindingCache(instance, binding)\n    },\n\n    beforeUnmount(el, binding) {\n      const uid = getDirectiveUid(binding)\n      const instance = getDirectiveInstance(el, propertyName, uid)\n\n      if (!instance) return\n\n      unbind(el)\n      cleanupDirectiveInstance(el, propertyName, uid)\n    },\n  }\n}\n"],"names":["getDirectiveUid","binding","instance","Error","$","uid","initDirectiveInstance","el","propertyName","elWithProps","Object","create","state","JSON","stringify","modifiers","value","destroying","getDirectiveInstance","cleanupDirectiveInstance","findProvides","vnode","ctx","root","stack","Set","walk","children","child","result","add","suspense","ssContent","Array","isArray","component","subTree","delete","console","error","from","reverse","findComponentParent","provides","componentDefaultsKey","buildProps","mounted","defaultsMap","defaultsKey","resolveActiveStatus","text","resolveContent","body","title","props","resolveDirectiveProps","bind","updated","$__element","unbind","newBinding","hasBindingChanged","updateBindingCache","beforeUnmount"],"mappings":"yFAmCO,SAASA,EAAgBC,GAC9B,IAAKA,EAAQC,SACX,MAAM,IAAIC,MAAM,oEAElB,OAAOF,EAAQC,SAASE,EAAEC,GAC5B,CAUO,SAASC,EACdC,EACAC,EACAH,EACAJ,GAGA,MAAMQ,EAAcF,EACpBE,EAAYD,GAAgBC,EAAYD,IAAiBE,OAAOC,OAAO,MAGvE,MAAMC,EAAgC,CACpCX,QAASY,KAAKC,UAAU,CAACb,EAAQc,UAAWd,EAAQe,QACpDC,YAAY,GAId,OADER,EAAYD,GAA0CH,GAAOO,EACxDA,CACT,CASO,SAASM,EACdX,EACAC,EACAH,GAEA,MAAMI,EAAcF,EACpB,OAAQE,EAAYD,KAAwDH,EAG9E,CAkCO,SAASc,EACdZ,EACAC,EACAH,GAEA,MAAMI,EAAcF,EACdL,EAAYO,EAAYD,KAAwDH,GAGlFH,IACFA,EAASe,YAAa,SACdR,EAAYD,GAA0CH,GAElE,CAIO,SAASe,EAAanB,EAA2BoB,GAMtD,OAJGA,EAAMC,MAAQrB,EAAQC,SAAUE,EAO9B,SACLiB,EACAE,GAGA,MAAMC,MAAYC,IACZC,EAAQC,IACZ,IAAA,MAAWC,KAASD,EAAU,CAC5B,IAAKC,EAAO,SAEZ,GAAIA,IAAUP,GAAUO,EAAMrB,IAAMc,EAAMd,IAAMqB,EAAMrB,KAAOc,EAAMd,GACjE,OAAO,EAIT,IAAIsB,EAQJ,GATAL,EAAMM,IAAIF,GAENA,EAAMG,SACRF,EAASH,EAAK,CAACE,EAAMI,YACZC,MAAMC,QAAQN,EAAMD,UAC7BE,EAASH,EAAKE,EAAMD,UACXC,EAAMO,WAAWd,QAC1BQ,EAASH,EAAK,CAACE,EAAMO,WAAWC,WAE9BP,EACF,OAAOA,EAETL,EAAMa,OAAOT,EACf,CAEA,OAAO,GAET,IAAKF,EAAK,CAACH,EAAKa,UAGd,OADAE,QAAQC,MAAM,6DACPhB,EAIT,MAAMM,EAASI,MAAMO,KAAKhB,GAAOiB,UACjC,IAAA,MAAWb,KAASC,EAClB,GAAID,EAAMO,UACR,OAAOP,EAAMO,UAGjB,OAAOZ,CACT,CAnDQmB,CAAoBrB,EAAOpB,EAAQC,SAAUE,IAAIuC,SACjDtB,EAAMC,KAAKqB,WAAa1C,EAAQC,SAAUE,EAAEuC,QAGpD,iCAwDO,SACLnC,EACAoC,EACAC,GAOA,MAAO,CACL,OAAAC,CAAQvC,EAAIN,EAASoB,GACnB,MAAMhB,EAAML,EAAgBC,GACtB8C,EAAe3B,EAAanB,EAASoB,GAA+B2B,EAAAA,cACtEhC,MAEJ,IADiBiC,EAAAA,oBAAoBhD,EAAQe,OAC9B,OAEf,MAAMkC,EAAOC,EAAAA,eAAelD,EAAQe,MAAOT,GAE3C,IAAK2C,EAAKE,OAASF,EAAKG,MAAO,OAG/B/C,EAAsBC,EAAIC,EAAcH,EAAKJ,GAE7C,MAAMqD,EAAQT,EACVA,EAAWK,EAAMH,IAAcH,GAAuB3C,EAASM,GAC/D,IACMwC,IAAcH,SAAyB,KACxCW,EAAAA,sBAAsBtD,EAASM,MAC/B2C,GAGTM,OAAKjD,EAAIN,EAASqD,EACpB,EAEA,OAAAG,CAAQlD,EAAIN,EAASoB,GACnB,MAAMhB,EAAML,EAAgBC,GAC5B,IAAIC,EAAWgB,EAAqBX,EAAIC,EAAcH,GAEtD,MAAM0C,EAAe3B,EAAanB,EAASoB,GAA+B2B,EAAAA,cACtEhC,MAKJ,IAHiBiC,EAAAA,oBAAoBhD,EAAQe,OAQ3C,YAJId,GAAYK,EAAGmD,aACjBC,EAAAA,OAAOpD,GACPY,EAAyBZ,EAAIC,EAAcH,KAK/C,MAAM6C,EAAOC,EAAAA,eAAelD,EAAQe,MAAOT,GAE3C,IAAK2C,EAAKE,OAASF,EAAKG,MAMtB,YAJInD,GAAYK,EAAGmD,aACjBC,EAAAA,OAAOpD,GACPY,EAAyBZ,EAAIC,EAAcH,KAO/C,IAAKH,EAAU,CACbA,EAAWI,EAAsBC,EAAIC,EAAcH,EAAKJ,GAExD,MAAMqD,EAAQT,EACVA,EAAWK,EAAMH,IAAcH,GAAuB3C,EAASM,GAC/D,IACMwC,IAAcH,SAAyB,KACxCW,EAAAA,sBAAsBtD,EAASM,MAC/B2C,GAIT,YADAM,OAAKjD,EAAIN,EAASqD,EAEpB,CAGA,IA7LC,SACLpD,EACAD,GAEA,MAAM2D,EAAa/C,KAAKC,UAAU,CAACb,EAAQc,UAAWd,EAAQe,QAC9D,OAAOd,EAASD,UAAY2D,CAC9B,CAuLWC,CAAkB3D,EAAUD,GAAU,OAG3C,GAAIC,EAASe,WAAY,OAEzB0C,EAAAA,OAAOpD,GAEP,MAAM+C,EAAQT,EACVA,EAAWK,EAAMH,IAAcH,GAAuB3C,EAASM,GAC/D,IACMwC,IAAcH,SAAyB,KACxCW,EAAAA,sBAAsBtD,EAASM,MAC/B2C,GAGTM,OAAKjD,EAAIN,EAASqD,GA/LjB,SACLpD,EACAD,GAEAC,EAASD,QAAUY,KAAKC,UAAU,CAACb,EAAQc,UAAWd,EAAQe,OAChE,CA6LM8C,CAAmB5D,EAAUD,EAC/B,EAEA,aAAA8D,CAAcxD,EAAIN,GAChB,MAAMI,EAAML,EAAgBC,GACXiB,EAAqBX,EAAIC,EAAcH,KAIxDsD,EAAAA,OAAOpD,GACPY,EAAyBZ,EAAIC,EAAcH,GAC7C,EAEJ"}