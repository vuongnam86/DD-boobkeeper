import { R as RX_SPACE_SPLIT, d as RX_HASH_ID, e as RX_HASH } from "../../../constants-Cx335y3L.mjs";
import "vue";
import { f as findProvides } from "../../../utils-BfbvBFtw.mjs";
import { s as showHideRegistryKey } from "../../../keys-BLeKMItg.mjs";
import { g as getActiveShowHide } from "../../../registryAccess-CjgwYkQG.mjs";
const getTargets = (binding, el) => {
  const { modifiers, arg, value } = binding;
  const targets = Object.keys(modifiers || {});
  const localValue = typeof value === "string" ? value.split(RX_SPACE_SPLIT) : value;
  if (el.tagName.toLowerCase() === "a") {
    const href = el.getAttribute("href") || "";
    if (RX_HASH_ID.test(href)) {
      targets.push(href.replace(RX_HASH, ""));
    }
  }
  Array.prototype.concat.apply([], [arg, localValue]).forEach((t) => typeof t === "string" && targets.push(t));
  return targets.filter((t, index, arr) => t && arr.indexOf(t) === index);
};
const handleUpdate = (el, binding, vnode) => {
  const targets = getTargets(binding, el);
  if (targets.length === 0) return;
  const provides = findProvides(binding, vnode);
  const showHideMap = provides[showHideRegistryKey]?.values ?? null;
  if (el.dataset.bvtoggle) {
    const oldTargets = (el.dataset.bvtoggle || "").split(" ");
    if (oldTargets.length === 0) return;
    for (const targetId of oldTargets) {
      const showHide = getActiveShowHide(showHideMap, targetId);
      if (!showHide) {
        continue;
      }
      if (!targets.includes(targetId)) {
        showHide.unregisterTrigger("click", el, false);
      }
    }
  }
  el.dataset.bvtoggle = targets.join(" ");
  targets.forEach(async (targetId) => {
    let count = 0;
    const maxAttempts = 5;
    const delayMs = 100;
    while (count < maxAttempts) {
      if (!el.dataset.bvtoggle) {
        return;
      }
      const showHide = getActiveShowHide(showHideMap, targetId);
      if (!showHide) {
        count++;
        if (count < maxAttempts) {
          await new Promise((resolve) => setTimeout(resolve, delayMs));
          continue;
        }
        if (el.dataset.bvtoggle) {
          console.warn(
            `[v-b-toggle] Target with ID ${targetId} not found after ${maxAttempts * delayMs}ms`
          );
        }
        break;
      }
      if (!el.dataset.bvtoggle) return;
      showHide.unregisterTrigger("click", el, false);
      showHide.registerTrigger("click", el);
      break;
    }
  });
  el.setAttribute("aria-controls", targets.join(" "));
};
const handleUnmount = (el, binding, vnode) => {
  const targets = getTargets(binding, el);
  if (targets.length === 0) return;
  const provides = findProvides(binding, vnode);
  const showHideMap = provides[showHideRegistryKey]?.values ?? null;
  targets.forEach((targetId) => {
    const showHide = getActiveShowHide(showHideMap, targetId);
    if (!showHide) {
      return;
    }
    showHide.unregisterTrigger("click", el, true);
  });
  el.removeAttribute("aria-controls");
  delete el.dataset.bvtoggle;
};
const vBToggle = {
  mounted: handleUpdate,
  updated: handleUpdate,
  unmounted: handleUnmount
};
export {
  vBToggle
};
//# sourceMappingURL=index.mjs.map
