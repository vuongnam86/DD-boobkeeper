{"version":3,"file":"index.umd.js","sources":["../../../../src/composables/usePopover/index.ts"],"sourcesContent":["import {\n  inject,\n  isReadonly,\n  isRef,\n  markRaw,\n  onScopeDispose,\n  type Ref,\n  shallowRef,\n  toValue,\n  watch,\n} from 'vue'\nimport {orchestratorRegistryKey} from '../../utils/keys'\nimport type {\n  OrchestratorCreateOptions,\n  PopoverOrchestratorArrayValue,\n  PopoverOrchestratorCreateParam,\n  PopoverOrchestratorParam,\n  PromiseWithComponent,\n  TooltipOrchestratorArrayValue,\n  TooltipOrchestratorCreateParam,\n  TooltipOrchestratorParam,\n} from '../../types/ComponentOrchestratorTypes'\nimport {BPopover, BTooltip} from '../../components'\nimport {buildPromise} from '../orchestratorShared'\n\nexport const usePopover = () => {\n  const orchestratorRegistry = inject(orchestratorRegistryKey)\n  if (!orchestratorRegistry) {\n    throw new Error(\n      'usePopover() must be called within setup(), and BApp, useRegistry or plugin must be installed/provided.'\n    )\n  }\n\n  const {store, _isOrchestratorInstalled} = orchestratorRegistry\n\n  /**\n   * Create a popover or tooltip\n   * @param obj The popover or tooltip props\n   * @param tooltip If true, create a tooltip, otherwise create a popover\n   * @returns {PromiseWithComponent<typeof BPopover | typeof BTooltip, PopoverOrchestratorParam>} A promise object with methods to control the popover (show, hide, toggle, get, set, destroy)\n   */\n  const create = (\n    obj: PopoverOrchestratorCreateParam | TooltipOrchestratorCreateParam,\n    tooltip?: boolean,\n    options: OrchestratorCreateOptions = {keep: true}\n  ): PromiseWithComponent<\n    typeof BPopover | typeof BTooltip,\n    PopoverOrchestratorParam | TooltipOrchestratorParam\n  > => {\n    if (!_isOrchestratorInstalled.value) {\n      throw new Error(\n        'The BPopoverOrchestrator component must be mounted to use the popover controller'\n      )\n    }\n\n    const resolvedProps = isRef(obj) ? obj : shallowRef(obj)\n    const _self = resolvedProps.value?.id || Symbol('Popover controller')\n\n    const promise = buildPromise<\n      typeof BPopover | typeof BTooltip,\n      PopoverOrchestratorParam | TooltipOrchestratorParam,\n      PopoverOrchestratorArrayValue | TooltipOrchestratorArrayValue\n    >(_self, store as Ref<PopoverOrchestratorArrayValue[] | TooltipOrchestratorArrayValue[]>)\n\n    promise.stop = watch(\n      resolvedProps,\n      (_newValue) => {\n        const newValue = {...toValue(_newValue)}\n        const previousIndex = store.value.findIndex((el) => el._self === _self)\n        const previous =\n          previousIndex === -1\n            ? {_component: tooltip ? markRaw(BTooltip) : markRaw(BPopover)}\n            : store.value[previousIndex]\n        // if (!previous) return\n        const v: PopoverOrchestratorArrayValue | TooltipOrchestratorArrayValue = tooltip\n          ? ({\n              ...previous,\n              type: 'tooltip',\n              _self,\n              position: 'popover',\n              promise,\n              options,\n            } as TooltipOrchestratorArrayValue)\n          : ({\n              ...previous,\n              type: 'popover',\n              _self,\n              position: 'popover',\n              promise,\n              options,\n            } as PopoverOrchestratorArrayValue)\n\n        for (const key in newValue) {\n          if (key.startsWith('on')) {\n            v[key as keyof PopoverOrchestratorCreateParam] =\n              newValue[key as keyof PopoverOrchestratorCreateParam]\n          } else if (key === 'component' && newValue.component) {\n            v._component = markRaw(newValue.component)\n          } else if (key === 'slots' && newValue.slots) {\n            v.slots = markRaw(newValue.slots)\n          } else {\n            v[key as keyof PopoverOrchestratorCreateParam] = toValue(\n              newValue[key as keyof PopoverOrchestratorCreateParam]\n            )\n          }\n        }\n\n        v.modelValue = v.modelValue ?? false\n        v['onUpdate:modelValue'] = (val: boolean) => {\n          newValue['onUpdate:modelValue']?.(val)\n          const {modelValue} = toValue(obj)\n          if (isRef(obj) && !isRef(modelValue)) obj.value.modelValue = val\n          if (isRef(modelValue) && !isReadonly(modelValue)) {\n            ;(modelValue as Ref<PopoverOrchestratorParam['modelValue']>).value = val\n          }\n          if (v.modelValue !== val) {\n            const popover = store.value.find((el) => el._self === _self)\n            if (popover) {\n              popover.modelValue = val\n            }\n          }\n        }\n        if (previousIndex === -1) {\n          store.value.push(v)\n        } else {\n          store.value.splice(previousIndex, 1, v)\n        }\n      },\n      {\n        immediate: true,\n        deep: true,\n      }\n    )\n\n    onScopeDispose(() => {\n      const popover = store.value.find((el) => el._self === _self)\n      if (popover) {\n        popover.promise.value.destroy?.()\n      }\n    }, true)\n\n    return promise.value\n  }\n\n  const tooltip = (\n    obj: TooltipOrchestratorCreateParam,\n    options: OrchestratorCreateOptions = {keep: true}\n  ) => create(obj, true, options)\n\n  const popover = (\n    obj: PopoverOrchestratorCreateParam,\n    options: OrchestratorCreateOptions = {keep: true}\n  ) => create(obj, false, options)\n\n  return {\n    _isOrchestratorInstalled,\n    create,\n    popover,\n    tooltip,\n    store,\n  }\n}\n\n/**\n * @deprecated use usePopover() instead.\n * @returns {ReturnType<typeof usePopover>} The popover controller\n */\nexport const usePopoverController = usePopover\n"],"names":["usePopover","orchestratorRegistry","inject","orchestratorRegistryKey","Error","store","_isOrchestratorInstalled","create","obj","tooltip","options","keep","value","resolvedProps","isRef","shallowRef","_self","id","Symbol","promise","buildPromise","stop","watch","_newValue","newValue","toValue","previousIndex","findIndex","el","previous","_component","markRaw","BTooltip","BPopover","v","type","position","key","startsWith","component","slots","modelValue","val","isReadonly","popover","find","push","splice","immediate","deep","onScopeDispose","destroy","usePopoverController"],"mappings":"wnBAyBaA,EAAa,KACxB,MAAMC,EAAuBC,EAAAA,OAAOC,2BACpC,IAAKF,EACH,MAAM,IAAIG,MACR,2GAIJ,MAAMC,MAACA,EAAAC,yBAAOA,GAA4BL,EAQpCM,EAAS,CACbC,EACAC,EACAC,EAAqC,CAACC,MAAM,MAK5C,IAAKL,EAAyBM,MAC5B,MAAM,IAAIR,MACR,oFAIJ,MAAMS,EAAgBC,EAAAA,MAAMN,GAAOA,EAAMO,EAAAA,WAAWP,GAC9CQ,EAAQH,EAAcD,OAAOK,IAAMC,OAAO,sBAE1CC,EAAUC,EAAAA,aAIdJ,EAAOX,GA+ET,OA7EAc,EAAQE,KAAOC,EAAAA,MACbT,EACCU,IACC,MAAMC,EAAW,IAAIC,EAAAA,QAAQF,IACvBG,EAAgBrB,EAAMO,MAAMe,UAAWC,GAAOA,EAAGZ,QAAUA,GAC3Da,GACc,IAAlBH,EACI,CAACI,WAAYrB,EAAUsB,EAAAA,QAAQC,EAAAA,WAAYD,EAAAA,QAAQE,EAAAA,YACnD5B,EAAMO,MAAMc,GAEZQ,EAAmEzB,EACpE,IACIoB,EACHM,KAAM,UACNnB,QACAoB,SAAU,UACVjB,UACAT,WAED,IACImB,EACHM,KAAM,UACNnB,QACAoB,SAAU,UACVjB,UACAT,WAGN,IAAA,MAAW2B,KAAOb,EACZa,EAAIC,WAAW,MACjBJ,EAAEG,GACAb,EAASa,GACM,cAARA,GAAuBb,EAASe,UACzCL,EAAEJ,WAAaC,UAAQP,EAASe,WACf,UAARF,GAAmBb,EAASgB,MACrCN,EAAEM,MAAQT,UAAQP,EAASgB,OAE3BN,EAAEG,GAA+CZ,EAAAA,QAC/CD,EAASa,IAKfH,EAAEO,WAAaP,EAAEO,aAAc,EAC/BP,EAAE,uBAA0BQ,IAC1BlB,EAAS,yBAAyBkB,GAClC,MAAMD,WAACA,GAAchB,EAAAA,QAAQjB,GAK7B,GAJIM,EAAAA,MAAMN,KAASM,EAAAA,MAAM2B,KAAajC,EAAII,MAAM6B,WAAaC,GACzD5B,EAAAA,MAAM2B,KAAgBE,EAAAA,WAAWF,KACjCA,EAA2D7B,MAAQ8B,GAEnER,EAAEO,aAAeC,EAAK,CACxB,MAAME,EAAUvC,EAAMO,MAAMiC,KAAMjB,GAAOA,EAAGZ,QAAUA,GAClD4B,IACFA,EAAQH,WAAaC,EAEzB,IAEoB,IAAlBhB,EACFrB,EAAMO,MAAMkC,KAAKZ,GAEjB7B,EAAMO,MAAMmC,OAAOrB,EAAe,EAAGQ,IAGzC,CACEc,WAAW,EACXC,MAAM,IAIVC,EAAAA,eAAe,KACb,MAAMN,EAAUvC,EAAMO,MAAMiC,KAAMjB,GAAOA,EAAGZ,QAAUA,GAClD4B,GACFA,EAAQzB,QAAQP,MAAMuC,cAEvB,GAEIhC,EAAQP,OAajB,MAAO,CACLN,2BACAC,SACAqC,QARc,CACdpC,EACAE,EAAqC,CAACC,MAAM,KACzCJ,EAAOC,GAAK,EAAOE,GAMtBD,QAdc,CACdD,EACAE,EAAqC,CAACC,MAAM,KACzCJ,EAAOC,GAAK,EAAME,GAYrBL,UAQS+C,EAAuBpD"}