import { e as unbind, g as resolveActiveStatus, h as resolveContent, d as resolveDirectiveProps, j as bind } from "./floatingUi-DAKhZxeT.mjs";
import { f as defaultsKey } from "./keys-BLeKMItg.mjs";
function getDirectiveUid(binding) {
  if (!binding.instance) {
    throw new Error("[Bootstrap-Vue-Next] Directive binding.instance is not available");
  }
  return binding.instance.$.uid;
}
function initDirectiveInstance(el, propertyName, uid, binding) {
  const elWithProps = el;
  elWithProps[propertyName] = elWithProps[propertyName] ?? /* @__PURE__ */ Object.create(null);
  const state = {
    binding: JSON.stringify([binding.modifiers, binding.value]),
    destroying: false
  };
  elWithProps[propertyName][uid] = state;
  return state;
}
function getDirectiveInstance(el, propertyName, uid) {
  const elWithProps = el;
  return elWithProps[propertyName]?.[uid];
}
function hasBindingChanged(instance, binding) {
  const newBinding = JSON.stringify([binding.modifiers, binding.value]);
  return instance.binding !== newBinding;
}
function updateBindingCache(instance, binding) {
  instance.binding = JSON.stringify([binding.modifiers, binding.value]);
}
function cleanupDirectiveInstance(el, propertyName, uid) {
  const elWithProps = el;
  const instance = elWithProps[propertyName]?.[uid];
  if (instance) {
    instance.destroying = true;
    delete elWithProps[propertyName][uid];
  }
}
function findProvides(binding, vnode) {
  const provides = (vnode.ctx === binding.instance.$ ? findComponentParent(vnode, binding.instance.$)?.provides : vnode.ctx?.provides) ?? binding.instance.$.provides;
  return provides;
}
function findComponentParent(vnode, root) {
  const stack = /* @__PURE__ */ new Set();
  const walk = (children) => {
    for (const child of children) {
      if (!child) continue;
      if (child === vnode || child.el && vnode.el && child.el === vnode.el) {
        return true;
      }
      stack.add(child);
      let result2;
      if (child.suspense) {
        result2 = walk([child.ssContent]);
      } else if (Array.isArray(child.children)) {
        result2 = walk(child.children);
      } else if (child.component?.vnode) {
        result2 = walk([child.component?.subTree]);
      }
      if (result2) {
        return result2;
      }
      stack.delete(child);
    }
    return false;
  };
  if (!walk([root.subTree])) {
    console.error("Could not find original vnode,  will not inherit provides");
    return root;
  }
  const result = Array.from(stack).reverse();
  for (const child of result) {
    if (child.component) {
      return child.component;
    }
  }
  return root;
}
function createFloatingDirective(propertyName, componentDefaultsKey, buildProps) {
  return {
    mounted(el, binding, vnode) {
      const uid = getDirectiveUid(binding);
      const defaultsMap = findProvides(binding, vnode)[defaultsKey]?.value;
      const isActive = resolveActiveStatus(binding.value);
      if (!isActive) return;
      const text = resolveContent(binding.value, el);
      if (!text.body && !text.title) return;
      initDirectiveInstance(el, propertyName, uid, binding);
      const props = buildProps ? buildProps(text, defaultsMap?.[componentDefaultsKey], binding, el) : {
        ...defaultsMap?.[componentDefaultsKey] || void 0,
        ...resolveDirectiveProps(binding, el),
        ...text
      };
      bind(el, binding, props);
    },
    updated(el, binding, vnode) {
      const uid = getDirectiveUid(binding);
      let instance = getDirectiveInstance(el, propertyName, uid);
      const defaultsMap = findProvides(binding, vnode)[defaultsKey]?.value;
      const isActive = resolveActiveStatus(binding.value);
      if (!isActive) {
        if (instance && el.$__element) {
          unbind(el);
          cleanupDirectiveInstance(el, propertyName, uid);
        }
        return;
      }
      const text = resolveContent(binding.value, el);
      if (!text.body && !text.title) {
        if (instance && el.$__element) {
          unbind(el);
          cleanupDirectiveInstance(el, propertyName, uid);
        }
        return;
      }
      if (!instance) {
        instance = initDirectiveInstance(el, propertyName, uid, binding);
        const props2 = buildProps ? buildProps(text, defaultsMap?.[componentDefaultsKey], binding, el) : {
          ...defaultsMap?.[componentDefaultsKey] || void 0,
          ...resolveDirectiveProps(binding, el),
          ...text
        };
        bind(el, binding, props2);
        return;
      }
      if (!hasBindingChanged(instance, binding)) return;
      if (instance.destroying) return;
      unbind(el);
      const props = buildProps ? buildProps(text, defaultsMap?.[componentDefaultsKey], binding, el) : {
        ...defaultsMap?.[componentDefaultsKey] || void 0,
        ...resolveDirectiveProps(binding, el),
        ...text
      };
      bind(el, binding, props);
      updateBindingCache(instance, binding);
    },
    beforeUnmount(el, binding) {
      const uid = getDirectiveUid(binding);
      const instance = getDirectiveInstance(el, propertyName, uid);
      if (!instance) return;
      unbind(el);
      cleanupDirectiveInstance(el, propertyName, uid);
    }
  };
}
export {
  createFloatingDirective as c,
  findProvides as f,
  getDirectiveUid as g
};
//# sourceMappingURL=utils-BfbvBFtw.mjs.map
